// Generated by CoffeeScript 1.9.2

/*
var grammar = {
    'R': [['S']],
    'S': [['S', 'add_sub', 'M'], ['M'], ['num']],
    'M': [['M', 'mul_div', 'T'], ['T'], ['num']],
    'T': [['num']]
};
grammar.partOfSpeech = function( word ) {
    if( '+' == word || '-' == word ) return ['add_sub'];
    if( '*' == word || '/' == word ) return ['mul_div'];
    return ['num'];
}
 */
var grammar, parse, processGrammar;

grammar = ['R -> S', 'S -> S add_sub M | M | num', 'M -> M mul_div T | T | num', 'T -> num', 'num -> 2 | 3 | 4', 'add_sub -> + | -', 'mul_div -> * | /'];

parse = function(words, grammar, rootRule) {
  var i;
  var i;
  var id;
  var i;
  var state;
  var addToChart, chart, completer, expectedNonTerminal, i, id, idToStateMap, incomplete, initialState, j, lastChartColumn, log, predictor, rootRuleRhss, roots, scanner, state;
  chart = [];
  incomplete = function(state) {
    return state['dot'] < state['rhs'].length;
  };
  expectedNonTerminal = function(state, grammar) {
    var expected;
    expected = state['rhs'][state['dot']];
    if (grammar[expected]) {
      return true;
    }
    return false;
  };
  addToChart = function(newState, position) {
    var chartState, x;
    if (!newState['ref']) {
      newState['ref'] = [];
    }
    newState['id'] = id;
    for (x in chart[position]) {
      chartState = chart[position][x];
      if (chartState['lhs'] === newState['lhs'] && chartState['dot'] === newState['dot'] && chartState['pos'] === newState['pos'] && JSON.stringify(chartState['rhs']) === JSON.stringify(newState['rhs'])) {
        chartState['ref'] = chartState['ref'].concat(newState['ref']);
        return;
      }
    }
    chart[position].push(newState);
    idToStateMap[id] = newState;
    id++;
  };
  predictor = function(state, j, grammar) {
    var i, newState, nonTerm, productions;
    nonTerm = state['rhs'][state['dot']];
    productions = grammar[nonTerm];
    for (i in productions) {
      newState = {
        'lhs': nonTerm,
        'rhs': productions[i],
        'dot': 0,
        'pos': j
      };
      addToChart(newState, j);
    }
  };
  scanner = function(state, j, grammar) {
    var i, newState, term, termPOS;
    term = state['rhs'][state['dot']];
    termPOS = grammar.partOfSpeech(words[j]);
    termPOS.push(words[j]);
    for (i in termPOS) {
      if (term === termPOS[i]) {
        newState = {
          'lhs': term,
          'rhs': [words[j]],
          'dot': 1,
          'pos': j
        };
        addToChart(newState, j + 1);
        break;
      }
    }
  };
  completer = function(state, k) {
    var i, newState, parentChart, stateI;
    parentChart = chart[state['pos']];
    for (i in parentChart) {
      stateI = parentChart[i];
      if (stateI['rhs'][stateI['dot']] === state['lhs']) {
        newState = {
          'lhs': stateI['lhs'],
          'rhs': stateI['rhs'],
          'dot': stateI['dot'] + 1,
          'pos': stateI['pos'],
          'ref': stateI['ref'].slice()
        };
        newState['ref'].push({
          'dot': stateI['dot'],
          'ref': state['id']
        });
        addToChart(newState, k);
      }
    }
  };
  log = function(message, chart) {
    var o;
    console.log(message);
    for (o in chart) {
      console.log(JSON.stringify(chart[o]));
    }
    console.log();
  };
  i = 0;
  while (i < words.length + 1) {
    chart[i] = [];
    i++;
  }
  idToStateMap = {};
  id = 0;
  rootRuleRhss = grammar[rootRule];
  for (i in rootRuleRhss) {
    initialState = {
      'lhs': rootRule,
      'rhs': rootRuleRhss[i],
      'dot': 0,
      'pos': 0
    };
    addToChart(initialState, 0);
  }
  log('init', chart);
  i = 0;
  while (i < words.length + 1) {
    j = 0;
    while (j < chart[i].length) {
      state = chart[i][j];
      if (incomplete(state)) {
        if (expectedNonTerminal(state, grammar)) {
          predictor(state, i, grammar);
          log('predictor', chart);
        } else {
          scanner(state, i, grammar);
          log('scanner', chart);
        }
      } else {
        completer(state, i);
        log('completer', chart);
      }
      j++;
    }
    i++;
  }
  log('done', chart);
  console.log('');
  for (id in idToStateMap) {
    console.log(id + '\u0009' + JSON.stringify(idToStateMap[id], null, 0));
  }
  roots = [];
  lastChartColumn = chart[chart.length - 1];
  for (i in lastChartColumn) {
    state = lastChartColumn[i];
    if (state['lhs'] === rootRule && !incomplete(state)) {
      roots.push(state);
    }
  }
  console.log('\n' + 'roots');
  console.log(JSON.stringify(roots, null, 0));
};

processGrammar = function(grammar) {
  var i, j, lhs, parts, processed, rhs, rhsParts, rule;
  processed = {};
  for (i in grammar) {
    rule = grammar[i];
    parts = rule.split('->');
    lhs = parts[0].trim();
    rhs = parts[1].trim();
    if (!processed[lhs]) {
      processed[lhs] = [];
    }
    rhsParts = rhs.split('|');
    for (j in rhsParts) {
      processed[lhs].push(rhsParts[j].trim().split(' '));
    }
  }
  processed.partOfSpeech = function(word) {
    return [];
  };
  return processed;
};

parse('2 + 3 * 4'.split(' '), processGrammar(grammar), 'R');
