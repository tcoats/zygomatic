// Generated by CoffeeScript 1.9.2
var EOF, escape, parse, stringify;

EOF = -1;

parse = function(input) {
  var eat, error, escaped, expression, expressions, grammar, id, isChar, line, linePos, nonterminal, peek, pos, production, term, terminal, terminal_text, text, ws;
  pos = 0;
  line = 1;
  linePos = 0;
  error = function(msg) {
    throw new SyntaxError(msg + " at " + line + ":" + linePos);
  };
  peek = function() {
    if (pos >= input.length) {
      return EOF;
    }
    return input[pos];
  };
  eat = function(expected) {
    var ch;
    ch = peek();
    if (expected !== void 0 && expected !== ch) {
      error("Expected " + expected + ", got " + ch);
    }
    if (ch === EOF) {
      return EOF;
    }
    pos++;
    linePos++;
    return ch;
  };
  ws = function() {
    var ch, ret;
    ret = '';
    ch = void 0;
    while (' \n\u0009'.indexOf(ch = peek()) >= 0) {
      if (ch === '\n') {
        line++;
        linePos = 0;
      }
      ret += eat();
    }
    return ret;
  };
  escaped = function() {
    var ch;
    eat('\\');
    ch = peek();
    switch (ch) {
      case 'n':
        eat();
        return '\n';
      case 't':
        eat();
        return '\u0009';
      case '"':
        eat();
        return '"';
      case '\\':
        eat();
        return '\\';
    }
    return error('Invalid escape sequence: \\' + ch);
  };
  isChar = function() {
    var ch;
    ch = peek();
    return ch !== EOF && (/[a-zA-Z0-9\-_|:=; \/\(\)]/.test(ch) || ch === '\\');
  };
  text = function() {
    var ch, ret;
    ret = '';
    ch = void 0;
    while (isChar()) {
      if (peek() === '\\') {
        ret += escaped();
      } else {
        ret += eat();
      }
    }
    return ret;
  };
  id = function() {
    var ch, ret;
    ret = '';
    ch = void 0;
    while (isChar()) {
      if (peek() === '\\') {
        ret += escaped();
      } else {
        ret += eat();
      }
    }
    return ret;
  };
  terminal_text = function() {
    var ch, ret;
    ret = '';
    ch = peek();
    while (isChar() || ch === '<' || ch === '>') {
      if (ch === '\\') {
        ret += escaped();
      } else {
        ret += eat();
      }
      ch = peek();
    }
    return ret;
  };
  terminal = function() {
    var res;
    eat('"');
    res = terminal_text();
    eat('"');
    return {
      type: 'terminal',
      text: res
    };
  };
  nonterminal = function() {
    var res;
    eat('<');
    res = id();
    eat('>');
    return {
      type: 'nonterminal',
      text: res
    };
  };
  term = function() {
    if (peek() === '<') {
      return nonterminal();
    } else {
      return terminal();
    }
  };
  expression = function() {
    var res;
    res = [term()];
    ws();
    while ('<"'.indexOf(peek()) >= 0) {
      res.push(term());
      ws();
    }
    return {
      type: 'expression',
      terms: res
    };
  };
  expressions = function() {
    var res;
    res = [expression()];
    while (peek() === '|') {
      eat('|');
      ws();
      res.push(expression());
    }
    return res;
  };
  production = function() {
    var lhs, rhs;
    lhs = nonterminal();
    ws();
    eat('=');
    ws();
    rhs = expressions();
    eat(';');
    return {
      type: 'production',
      lhs: lhs,
      rhs: rhs
    };
  };
  grammar = function() {
    var res;
    res = [production()];
    ws();
    while (peek() === '<') {
      res.push(production());
      ws();
    }
    return {
      type: 'grammar',
      productions: res
    };
  };
  return grammar();
};

escape = function(text) {
  return text.replace(/\\/g, '\\\\').replace(/\"/g, '\"').replace(/\n/g, '\\n').replace(/\t/g, '\\t');
};

stringify = function(node) {
  switch (node.type) {
    case 'terminal':
      return "\"" + (escape(node.text)) + "\"";
    case 'nonterminal':
      return escape(node.text);
    case 'expression':
      return node.terms.map(stringify).join(' ');
    case 'production':
      return (stringify(node.lhs)) + " = " + (node.rhs.map(stringify).join(' | ')) + ";";
    case 'grammar':
      return (node.productions.map(stringify).join('\n')) + "\n";
    default:
      throw new Error('Unknown node type: ' + node.type);
  }
};

module.exports = {
  parse: parse,
  stringify: stringify
};
